options
{
	// Use \ u escapes in streams AND use a reader for the query
	// => get both raw and escaped unicode
	JAVA_UNICODE_ESCAPE = true;
	UNICODE_INPUT = false;

	STATIC = false;
	// DEBUG_PARSER = true;
	// DEBUG_TOKEN_MANAGER   = true ;
}

PARSER_BEGIN(JavaCCParser)
package org.semanticweb.vlog4j.parser.javacc;

import java.util.List;
import java.util.ArrayList;

import org.semanticweb.vlog4j.parser.javacc.JavaCCParserBase;
import org.semanticweb.vlog4j.core.exceptions.PrefixDeclarationException;

import org.semanticweb.vlog4j.core.model.api.Rule;
import org.semanticweb.vlog4j.core.model.api.Literal;
import org.semanticweb.vlog4j.core.model.api.NegativeLiteral;
import org.semanticweb.vlog4j.core.model.api.PositiveLiteral;
import org.semanticweb.vlog4j.core.model.api.Term;
import org.semanticweb.vlog4j.core.model.api.Constant;

import org.semanticweb.vlog4j.core.model.implementation.Expressions;


public class JavaCCParser extends JavaCCParserBase
{
}

PARSER_END(JavaCCParser)


void parse() throws PrefixDeclarationException:
{
}
{
    ( base() )?
    ( prefix() )*
    ( statement() )*
    < EOF >
}

void base() throws PrefixDeclarationException:
{
    String iriString;
}
{
    < BASE > iriString = IRIREF() < DOT >
    {
        prefixDeclarations.setBase(iriString);
    }
}

void prefix() throws PrefixDeclarationException:
{
    Token t;
    String iriString;
}
{
    < PREFIX > t = < PNAME_NS > iriString = IRIREF() < DOT >
    {
         //note that prefix includes the colon (:)
         prefixDeclarations.setPrefix(t.image, iriString);
    }
}

void statement() throws PrefixDeclarationException:
{
    Rule r;
    PositiveLiteral l;
    resetVariableSets();
}
{
    LOOKAHEAD(rule()) r = rule() { rules.add(r);}
|   l = positiveLiteral(FormulaContext.HEAD) < DOT > //not from a rule
    {
		if (l.getVariables().isEmpty()) {
			facts.add(l);
		} else {
			throw new ParseException("Facts with variables are not allowed: " + l.toString());
		}

    }
}

Rule rule() throws PrefixDeclarationException:
{
    Rule rule;
    List < PositiveLiteral > head;
    List < Literal > body;
}
{
    head = listOfPositiveLiterals(FormulaContext.HEAD) < ARROW > body = listOfLiterals(FormulaContext.BODY) < DOT >
    {
        rule = Expressions.makeRule(Expressions.makePositiveConjunction(head), Expressions.makeConjunction(body));
        
        // check that the intersection between headExiVars and BodyVars is empty
        for (String variable : headExiVars) {
          if (bodyVars.contains(variable)) 
            throw new ParseException("Malformed rule " + rule.toString() + "\nExistential variable " + variable + " also used in rule body.");
        }

        // check that bodyVars contains headUniVars
        for (String variable : headUniVars) {
          if (!bodyVars.contains(variable)) 
            throw new ParseException("Unsafe rule " + rule.toString() + "\nUniversal variable " + variable + " occurs in head but not in body.");
        }

        return rule;
    }
}

List < PositiveLiteral > listOfPositiveLiterals(FormulaContext context) throws PrefixDeclarationException:
{
    PositiveLiteral l;
    List < PositiveLiteral > list = new ArrayList < PositiveLiteral > ();
}
{
    l = positiveLiteral(context)             { list.add(l); }
    ( < COMMA > l = positiveLiteral(context) { list.add(l); } )*
    { return list; }
}

List < Literal > listOfLiterals(FormulaContext context) throws PrefixDeclarationException:
{
    Literal l;
    List < Literal > list = new ArrayList < Literal > ();
}
{
    l = literal(context)             { list.add(l); }
    ( < COMMA > l = literal(context) { list.add(l); } )*
    { return list; }
}

Literal literal(FormulaContext context) throws PrefixDeclarationException:
{
    Literal l = null;
}
{
    l = positiveLiteral(context) { return l; }
|   l = negativeLiteral(context) { return l; }
}

PositiveLiteral positiveLiteral(FormulaContext context) throws PrefixDeclarationException:
{
    Token t;
    List < Term > terms;
    String predicateName;
}
{
    predicateName = predicateName() < LPAREN > terms = listOfTerms(context) < RPAREN >
    { return Expressions.makePositiveLiteral(predicateName, terms); }
}

NegativeLiteral negativeLiteral(FormulaContext context) throws PrefixDeclarationException:
{
    List < Term > terms;
    String predicateName;
}
{
    < TILDE > predicateName = predicateName() < LPAREN > terms = listOfTerms(context) < RPAREN >
    { return Expressions.makeNegativeLiteral(predicateName, terms); }
}

List < Term > listOfTerms(FormulaContext context) throws PrefixDeclarationException:
{
    Term t;
    List < Term > list = new ArrayList < Term > ();
}
{
    t = term(context)             { list.add(t); }
    ( < COMMA > t = term(context) { list.add(t); } )*
    { return list; }
}

String predicateName() throws PrefixDeclarationException:
{
    String s;
    Token t;
}
{
    s = IRI(false) { return s; }
|   t = < VARORPREDNAME > { return prefixDeclarations.absolutize(t.image); }
}

// we use an int to specify where a variable comes from
// 0 if the variable does not come from a rule
// 1 if the variable comes from the head of a rule
// 2 if the variable comes from the body of a rule
Term term(FormulaContext context) throws PrefixDeclarationException:
{
    Token t;
    String s;
    Constant c;
}
{
    s = IRI(false)       { return Expressions.makeConstant(s); }
|   LOOKAHEAD(booleanLiteral()) c = booleanLiteral() { return c; }
|   c = NumericLiteral() { return c; }
|   s = RDFLiteral()     { return Expressions.makeConstant(s); }
|   t = < UNIVAR >
    {
        s = t.image.substring(1);
        if (context == FormulaContext.HEAD)
            headUniVars.add(s);
        else if (context == FormulaContext.BODY)
            bodyVars.add(s);
        return Expressions.makeVariable(t.image.substring(1));
    }
|   t = < EXIVAR >
    {
        s = t.image.substring(1);
        if (context == FormulaContext.HEAD)
            headExiVars.add(s);
        if (context == FormulaContext.BODY)
            throw new ParseException("Existentialy quantified variables can not appear in the body. Line: " + t.beginLine + ", Column: "+ t.beginColumn);
        return Expressions.makeVariable(t.image.substring(1));
    }
|   t = < VARORPREDNAME > { return Expressions.makeConstant(prefixDeclarations.absolutize(t.image));}
}

/** [16] */
Constant NumericLiteral() :
{
    Token t;
}
{
    t = < INTEGER > { return createIntegerLiteral(t.image); }
|   t = < DECIMAL > { return createDecimalLiteral(t.image); }
|   t = < DOUBLE >  { return createDoubleLiteral(t.image); }
}

String RDFLiteral() throws PrefixDeclarationException:
{
    Token t;
    String lex = null;
    String lang = null;   // Optional lang tag and datatype.
    String dt = null;
}
{
    lex = String() ( lang = Langtag() | < DATATYPE > dt = IRI(true) )?
    { return strRDFLiteral(lex, lang, dt); }
}

String Langtag() :
{
    Token t;
}
{
    // Enumerate the directives here because they look like language tags.
    (
        t = < LANGTAG >
    )
    {
        String lang = stripChars(t.image, 1);
        return lang;
    }
}

Constant booleanLiteral() :
{
      Token t;
}
{
    t = < TRUE >   { return createBooleanLiteral(t.image); }
|   t = < FALSE >  { return createBooleanLiteral(t.image); }
}

String String():
{
    Token t;
    String lex;
}
{
    (
         t = < STRING_LITERAL1 >      { lex = stripQuotes(t.image);  }
    |    t = < STRING_LITERAL2 >      { lex = stripQuotes(t.image);  }
    |    t = < STRING_LITERAL_LONG1 > { lex = stripQuotes3(t.image); }
    |    t = < STRING_LITERAL_LONG2 > { lex = stripQuotes3(t.image); }
    )
    {
        lex = unescapeStr(lex, t.beginLine, t.beginColumn);
        return lex;
    }
}

String IRI(boolean includeAngleBrackets) throws PrefixDeclarationException:
{
    String iri;
}
{
    (
        iri = IRIREF()
    |   iri = PrefixedName()
    )
    { String result = prefixDeclarations.absolutize(iri);
      if (includeAngleBrackets)
          result = "<"+result+">";
      return result;
      //return "<"+prefixDeclarations.absolutize(iri)+">";
     }
}

String PrefixedName() throws PrefixDeclarationException:
{
    Token t;
}
{
    (
        t = < PNAME_LN >
    |   t = < PNAME_NS >
    )
    { return prefixDeclarations.resolvePrefixedName(t.image);}
    //{ return prefixDeclarations.resolvePrefixedName(t.image, t.beginLine, t.beginColumn);}
}

String IRIREF() :
{
    Token t;
}
{
    t = < IRI >
    {
        // we remove '<' and '>'
        return t.image.substring(1,t.image.length()-1);
    }
}

// ------------------------------------------
// Tokens
// Comments and whitespace
SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

TOKEN :
{
  < #WS :
    " "
  | "\t"
  | "\n"
  | "\r"
  | "\f" >
}

SPECIAL_TOKEN :
{
  < SINGLE_LINE_COMMENT :
    "#" (~[ "\n", "\r" ])*
    (
      "\n"
    | "\r"
    | "\r\n"
    )? >
}

// -------------------------------------------------
// Keywords : directives before LANGTAG
TOKEN :
{
  < PREFIX : "@prefix" >
| < BASE : "@base" >
}

TOKEN [ IGNORE_CASE ] :
{
  < TRUE : "'true'" >
| < FALSE : "'false'" >
  // -------------------------------------------------
| < INTEGER : ([ "-", "+" ])? < DIGITS > >
| 
  < DECIMAL :
    ([ "-", "+" ])?
    (
      (< DIGITS >)+ "." (< DIGITS >)*
    | "." (< DIGITS >)+
    ) 
  >
  // Required exponent.
| < DOUBLE :
    ([ "+", "-" ])?
    (
      ([ "0"-"9" ])+ "." ([ "0"-"9" ])* < EXPONENT >
    | "." ([ "0"-"9" ])+ (< EXPONENT >)
    | ([ "0"-"9" ])+ < EXPONENT >
    ) 
  >
| < #EXPONENT : [ "e", "E" ] ([ "+", "-" ])? ([ "0"-"9" ])+ >
| < #QUOTE_3D : "\"\"\"" >
| < #QUOTE_3S : "'''" >
  // "u" done by javacc input stream.  
  // "U" escapes not supported yet for Java strings
| < ECHAR :
    "\\"
    (
      "t"
    | "b"
    | "n"
    | "r"
    | "f"
    | "\\"
    | "\""
    | "'"
    ) >
| < STRING_LITERAL1 :
    // Single quoted string
    "'"
    (
      (~[ "'", "\\", "\n", "\r" ])
    | < ECHAR >
    )*
    "'" >
| < STRING_LITERAL2 :
    // Double quoted string
    "\""
    (
      (~[ "\"", "\\", "\n", "\r" ])
    | < ECHAR >
    )*
    "\"" >
| < STRING_LITERAL_LONG1 :
    < QUOTE_3S >
    (
      ~[ "'", "\\" ]
    | < ECHAR >
    | ("'" ~[ "'" ])
    | ("''" ~[ "'" ])
    )*
    < QUOTE_3S > >
| < STRING_LITERAL_LONG2 :
    < QUOTE_3D >
    (
      ~[ "\"", "\\" ]
    | < ECHAR >
    | ("\"" ~[ "\"" ])
    | ("\"\"" ~[ "\"" ])
    )*
    < QUOTE_3D > >
| < DIGITS : ([ "0"-"9" ])+ >
  // | <HEX: ["0"-"9"] | ["A"-"F"] | ["a"-"f"]>
}

TOKEN :
{
  // Includes # for relative URIs
  < IRI : "<" (~[ ">", "<", "\"", "{", "}", "^", "\\", "|", "`", "\u0000"-"\u0020" ])* ">" >
| < PNAME_NS : (< PN_PREFIX >)? ":" >
| < PNAME_LN : < PNAME_NS > < PN_LOCAL > >
| < BLANK_NODE_LABEL : "_:" < PN_LOCAL > >
| < UNIVAR : "?" < VARORPREDNAME > >
| < EXIVAR : "!" < VARORPREDNAME > >
| < LANGTAG :
    < AT > (< A2Z >)+
    (
      "-" (< A2ZN >)+
    )* >
| < #A2Z : [ "a"-"z", "A"-"Z" ] >
| < #A2ZN : [ "a"-"z", "A"-"Z", "0"-"9" ] >
}

TOKEN :
{
  < LPAREN : "(" >
| < RPAREN : ")" >
| < NIL :
    < LPAREN >
    (
      < WS >
    | < SINGLE_LINE_COMMENT >
    )*
    < RPAREN > >
| < LBRACE : "{" >
| < RBRACE : "}" >
| < LBRACKET : "[" >
| < RBRACKET : "]" >
| < ANON :
    < LBRACKET >
    (
      < WS >
    | < SINGLE_LINE_COMMENT >
    )*
    < RBRACKET > >
| < SEMICOLON : ";" >
| < COMMA : "," >
| < DOT : "." >
}

// Operator
TOKEN :
{
  < EQ : "=" >
| < ARROW : ":-" >
| < DOLLAR : "$" >
| < QMARK : "?" >
| < TILDE : "~" >
| < COLON : ":" >
  // | < PLUS:    "+" >
  // | < MINUS:   "-" >
| < STAR : "*" >
| < SLASH : "/" >
| < RSLASH : "\\" >
| < BOM : "\ufeff" >
  //| < AMP: "&" >
  //| < REM: "%" >
| < DATATYPE : "^^" >
| < AT : "@" >
}

TOKEN :
{
  < #PN_CHARS_BASE :
    [ "A"-"Z" ]
  | [ "a"-"z" ]
  | 
    [ "\u00c0"-"\u00d6" ]
  | [ "\u00d8"-"\u00f6" ]
  | [ "\u00f8"-"\u02ff" ]
  | 
    [ "\u0370"-"\u037d" ]
  | [ "\u037f"-"\u1fff" ]
  | 
    [ "\u200c"-"\u200d" ]
  | [ "\u2070"-"\u218f" ]
  | [ "\u2c00"-"\u2fef" ]
  | 
    [ "\u3001"-"\ud7ff" ]
  | [ "\uf900"-"\ufffd" ] 
  >
  // [#x10000-#xEFFFF]
| 
  < #PN_CHARS_U :
    < PN_CHARS_BASE >
  | "_" >
| 
  // No DOT
  < #PN_CHARS :
    (
      < PN_CHARS_U >
    | "-"
    | [ "0"-"9" ]
    | "\u00b7"
    | 
      [ "\u0300"-"\u036f" ]
    | [ "\u203f"-"\u2040" ]
    ) >
| 
  // No leading "_", no trailing ".", can have dot inside prefix name.
  < #PN_PREFIX :
    < PN_CHARS_BASE >
    (
      (
        < PN_CHARS >
      | "."
      )*
      < PN_CHARS >
    )? >
| 
  // With a leading "_", no dot at end of local name.
  < #PN_LOCAL :
    (
      < PN_CHARS_U >
    | [ "0"-"9" ]
    )
    (
      (
        < PN_CHARS >
      | "."
      )*
      < PN_CHARS >
    )? >
| 
  // NCNAME without "-" and ".", allowing leading digits.
  < VARORPREDNAME :
    (
      < PN_CHARS_U >
    | [ "0"-"9" ]
    )
    (
      < PN_CHARS_U >
    | [ "0"-"9" ]
    | "\u00b7"
    | [ "\u0300"-"\u036f" ]
    | [ "\u203f"-"\u2040" ]
    )* >
}

// Catch-all tokens.  Must be last.  
// Any non-whitespace.  Causes a parser exception, rather than a
// token manager error (with hidden line numbers).
// Only bad IRIs (e.g. spaces) now give unhelpful parse errors.
TOKEN :
{
  < #UNKNOWN : (~[ " ", "\t", "\n", "\r", "\f" ])+ >
}

SKIP :{< "%" (~["\n"])* "\n" >}
